# test_int-1
1. В mysql создали БД test.
2. Создали таблицу example_table cо столбцом col(столбец без индекса) и столбцом col_ind(столбец с индексом) для фунционального теста(будет 10 строчек) с помощью запроса  CREATE TABLE example_table ( col VARCHAR(255) NOT NULL, col_ind VARCHAR(255) NOT NULL,  INDEX (col_ind) );
3. Добавили данные в таблицу example_table для фунционального теста ( добавили 10 строчек, т.к. при большом количестве строк порядок результата запроса может отличаться для столбца с индексом и без) с помощью запроса INSERT INTO example_table (col, col_ind) VALUES ('RandomData1', 'RandomData1'), ('RandomData2', 'RandomData2'), ('RandomData3', 'RandomData3'), ('RandomData4', 'RandomData4'), ('RandomData5', 'RandomData5'), ('RandomData6', 'RandomData6'), ('RandomData7', 'RandomData7'), ('RandomData8', 'RandomData8'), ('RandomData9', 'RandomData9'), ('RandomData10', 'RandomData10');
4. Создали таблицу test1 cо столбцом addr(столбец без индекса) и столбцом addr_ind(столбец с индексом) для перфоманс теста(количество строк от 1000 до 2 000 000) с помощью запроса  CREATE TABLE test1 ( addr VARCHAR(255) NOT NULL, addr_ind VARCHAR(255) NOT NULL,  INDEX (addr_ind) );
5. С помощью insert.py добавили 2 000 000 строк с числами от 1 до 2 000 000 в таблицу test1
6. С помощью select.py сделали функциональные и перофманс тесты.
Отчет:
1. Запустив select.py , фунциональный тест для example_table( малое количество строк) показал, что результаты работы запросов на одинаковых данных не отличаются, когда на колонке str нет индекса и когда он есть, НО если в функциональном тесте использовать таблицу test1 , результаты работы запросов на одинаковых данных будут отличаться , порядок будет разный, это можно исправить , добавив в запрос  'ORDER BY addr ASC' или 'ORDER BY addr DESC' , тогда запрос будет выглядеть так: 'SELECT addr FROM test1 WHERE addr LIKE '%1234' ORDER BY addr ASC;' (аналогично добавить в запрос для столбца с индексом)
2. Запустив select.py , перфоманс тест для example_table не производился(малое количество данных и очень сложно о чем-то судить), перфоманс тест для test1 показал, что время выполнения запроса с индексом намного меньше времени запроса без индекса.
   Примеры:(результат запроса 1 строчка из 2000000, в pattern не используется %
   1. Результаты работы перофманс теста для таблицы с 2 000 000 строчек на запросы "SELECT addr FROM test1 WHERE addr LIKE '10034';" и "SELECT addr_ind FROM test1 WHERE addr_ind LIKE '10034';"
select.py::test_performance_select_like PASSED                               [100%]
Время запроса SELECT для столбца без индекса: 2.332368
Время запроса SELECT для столбца с индексом: 0.005862
Разница времени: 2.326506
   2. Результаты работы перофманс теста для таблицы с 2 000 000 строчек на запросы "SELECT addr FROM test1 WHERE addr LIKE '115352';" и "SELECT addr_ind FROM test1 WHERE addr_ind LIKE '115352';"
select.py::test_performance_select_like PASSED                               [100%]
Время запроса SELECT для столбца без индекса: 2.834613
Время запроса SELECT для столбца с индексом: 0.006021
Разница времени: 2.828592
   3. Результаты работы перофманс теста для таблицы с 2 000 000 строчек на запросы "SELECT addr FROM test1 WHERE addr LIKE '1000000';" и "SELECT addr_ind FROM test1 WHERE addr_ind LIKE '1000000';"
select.py::test_performance_select_like PASSED                               [100%]
Время запроса SELECT для столбца без индекса: 2.996503
Время запроса SELECT для столбца с индексом: 0.00102
Разница времени: 2.995483

Вывод : Время запросов с индексом и без отличается от 2 до 3 секунд и в 300 , в 400 , а то и в 2000 раз.

3. Запустив select.py , перфоманс тест для test1 для запросов в pattern которых присутствует % показал, что время выполнения запроса с индексом сравнимо со временем запроса без индекса и использование в запросе индекса не является эффективным.
   Примеры:(результат запроса несколько строк из 2000000, в  начале pattern  используется %)
   1. Результаты работы перофманс теста для таблицы с 2 000 000 строчек на запросы "SELECT addr FROM test1 WHERE addr LIKE '%123';" и "SELECT addr_ind FROM test1 WHERE addr_ind LIKE '%123';"
select.py::test_performance_select_like PASSED                               [100%]
Время запроса SELECT для столбца без индекса: 3.261443
Время запроса SELECT для столбца с индексом: 3.059325
Разница времени: 0.20211800000000002
   2. Результаты работы перофманс теста для таблицы с 2 000 000 строчек на запросы "SELECT addr FROM test1 WHERE addr LIKE '%12383';" и "SELECT addr_ind FROM test1 WHERE addr_ind LIKE '%12383';"
select.py::test_performance_select_like PASSED                               [100%]
Время запроса SELECT для столбца без индекса: 2.851031
Время запроса SELECT для столбца с индексом: 2.683474
Разница времени: 0.16755699999999996
    Примеры:(результат запроса несколько строк из 2000000, в  начале и в конце pattern  используется %)
  1. Результаты работы перофманс теста для таблицы с 2 000 000 строчек на запросы "SELECT addr FROM test1 WHERE addr LIKE '%12383%';" и "SELECT addr_ind FROM test1 WHERE addr_ind LIKE '%12383%';"
select.py::test_performance_select_like FAILED                               [100%]
Время запроса SELECT для столбца без индекса: 3.049151
Время запроса SELECT для столбца с индексом: 3.082209
Разница времени: -0.03305800000000003
  2. Результаты работы перофманс теста для таблицы с 2 000 000 строчек на запросы "SELECT addr FROM test1 WHERE addr LIKE '%12%';" и "SELECT addr_ind FROM test1 WHERE addr_ind LIKE '%12%';"
select.py::test_performance_select_like PASSED                               [100%]
Время запроса SELECT для столбца без индекса: 3.163998
Время запроса SELECT для столбца с индексом: 3.055366
Разница времени: 0.10863200000000006

Вывод : Время запросов с индексом и без сравнимо и мало отличается, иногда запросы с LIKE '%...%' выполняются быстрее без индекса, mysql не должен использовать индекс в таком случае , но все равно использует.
